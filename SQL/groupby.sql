-- REGEXP 이용해서 다수의 문자열 추출하기
-- 자동차 종류 별 특정 옵션이 포함된 자동차 수 구하기
SELECT CAR_TYPE, COUNT(CAR_ID) AS CARS 
  FROM CAR_RENTAL_COMPANY_CAR
 WHERE OPTIONS REGEXP "통풍시트|열선시트|가죽시트"
 GROUP BY CAR_TYPE
 ORDER BY CAR_TYPE

-- AS ""했을 때는  재정의한 이름으로 ORDER BY... 에서 사용하지 말것
-- 진료과별 총 예약 횟수 출력하기
SELECT MCDP_CD AS "진료과코드", COUNT(PT_NO) AS "5월예약건수"
  FROM APPOINTMENT
 WHERE DATE_FORMAT(APNT_YMD,"%Y-%m")="2022-05"
 GROUP BY MCDP_CD
 ORDER BY COUNT(PT_NO) ASC, MCDP_CD ASC

-- 입양 시각 구하기(1)
SELECT HOUR(DATETIME), COUNT(ANIMAL_ID)
  FROM ANIMAL_OUTS
 WHERE HOUR(DATETIME)>=9 AND HOUR(DATETIME)<20
 GROUP BY HOUR(DATETIME)
 ORDER BY HOUR(DATETIME)

-- 대여 횟수가 많은 자동차들의 월별 대여 횟수 구하기
SELECT MONTH(START_DATE) AS MONTH
     , CC.CAR_ID
     , COUNT(*) AS "RECORDS"
  FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY AS CC
  JOIN (
        SELECT CAR_ID
             , COUNT(*) AS CNT
          FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
         WHERE YEAR(START_DATE)=2022 AND MONTH(START_DATE) IN (8,9,10)
         GROUP BY CAR_ID
  ) SUB
    ON SUB.CAR_ID=CC.CAR_ID
 WHERE SUB.CNT >= 5 
       AND YEAR(START_DATE)=2022 AND MONTH(START_DATE) IN (8,9,10)
 GROUP BY MONTH(START_DATE), CAR_ID
 ORDER BY MONTH(START_DATE) ASC, CAR_ID DESC

-- SUM
 -- 카테고리 별 도서 판매량 집계하기
SELECT B.CATEGORY, SUM(BSY.SALES) AS TOTAL_SALES
  FROM BOOK B
  JOIN (SELECT *
  FROM BOOK_SALES BS
 WHERE DATE_FORMAT(SALES_DATE,"%Y-%m")="2022-01") BSY
    ON B.BOOK_ID=BSY.BOOK_ID
 GROUP BY B.CATEGORY
 ORDER BY B.CATEGORY ASC

 -- 카테고리 별 도서 판매량 집계하기
SELECT B.CATEGORY, SUM(BSY.SALES) AS TOTAL_SALES
  FROM BOOK B
  JOIN (SELECT *
  FROM BOOK_SALES BS
 WHERE DATE_FORMAT(SALES_DATE,"%Y-%m")="2022-01") BSY
    ON B.BOOK_ID=BSY.BOOK_ID
 GROUP BY B.CATEGORY
 ORDER BY B.CATEGORY ASC

-- 원하는 조건을 서브쿼리로 만들어 inner join 하여 데이터를 추려낼 수 있었다.
 -- 헤비 유저가 소유한 장소
SELECT P.ID, P.NAME, P.HOST_ID
  FROM PLACES P
INNER JOIN 
        (SELECT HOST_ID
           FROM PLACES
          GROUP BY HOST_ID
        HAVING COUNT(*)>=2) T1
        ON P.HOST_ID=T1.HOST_ID
ORDER BY ID

-- 입양 시각 구하기(2)
# SELECT 0시부터 23시까지 입양이 몇 건이나 발생했는지 조회
# GROUP BY 각 시간대별로
# ORDER BY 시간대 순으로 정렬
 
-- 가상 테이블 생성 WITH RECURSIVE
    -- index table create
WITH RECURSIVE tb1 AS (
    -- 초깃값 0 설정
    SELECT 0 AS HOUR
    UNION ALL
    -- 초깃값 이용해서 반복문 생성
    SELECT HOUR+1 FROM tb1 WHERE HOUR < 23
    -- index에 맞는 count값 설정
) , tb2 AS (
    SELECT HOUR(DATETIME) AS HOUR 
         , COUNT(DISTINCT ANIMAL_ID) AS CNT
      FROM ANIMAL_OUTS
     GROUP BY HOUR
)
-- 최종 조회문
-- 시간, 카운트수
SELECT tb1.HOUR
     , IF(tb2.CNT IS NULL, 0, CNT) AS COUNT
     # , CASE WHEN tb2.CNT IS NULL THEN 0 ELSE CNT END AS COUNT
-- 가상의 두 테이블을 합친다
FROM tb1
     LEFT JOIN tb2 
            ON tb1.HOUR = tb2.HOUR
ORDER BY HOUR

-- 식품분류별 가장 비싼 식품의 정보 조회하기
SELECT FP.CATEGORY, FP.PRICE MAX_PRICE, FP.PRODUCT_NAME
  FROM FOOD_PRODUCT FP,
       (SELECT CATEGORY,MAX(PRICE) MAX_PRICE
          FROM FOOD_PRODUCT
         GROUP BY CATEGORY) FM
 WHERE FP.CATEGORY=FM.CATEGORY -- JOIN 조건문
   AND FP.PRICE=FM.MAX_PRICE  -- JOIN 조건문
   AND FP.CATEGORY IN ('과자', '국', '김치', '식용유')  -- 출력할 열 조건문
 ORDER BY MAX_PRICE DESC

-- GROUP BY 를 실행하면 카테고리별로 존재하는 데이터 값 중 하나만 선택해서 추출해준다.
-- 해당 카테고리의 모든 데이터값을 이용하기 위해서 SUM, AVG ... 함수를 사용해야 한다!
-- 5월 식품들의 총매출 조회하기
SELECT FP.PRODUCT_ID
     , FP.PRODUCT_NAME
     , FP.PRICE*SUM(FO.AMOUNT) TOTAL_SALES
  FROM FOOD_PRODUCT FP
  JOIN FOOD_ORDER FO
    ON FP.PRODUCT_ID=FO.PRODUCT_ID
 WHERE YEAR(FO.PRODUCE_DATE)=2022 AND MONTH(FO.PRODUCE_DATE)=5
 GROUP BY FP.PRODUCT_ID
 ORDER BY TOTAL_SALES DESC, FP.PRODUCT_ID ASC

 -- 저자 별 카테고리 별 매출액 집계하기
# SELECT 저자 ID(AUTHOR_ID), 저자명(AUTHOR_NAME), 카테고리(CATEGORY), 매출액(TOTAL_SALES = 판매량 * 판매가) 
# WHERE 2022년 1월의 도서 판매 데이터
# GROUP BY 저자 별, 카테고리 별
# ORDER BY 저자 ID를 오름차순으로, 저자 ID가 같다면 카테고리를 내림차순
SELECT B.AUTHOR_ID, A.AUTHOR_NAME, B.CATEGORY, SUM(BS.SALES*B.PRICE)
  FROM BOOK B
  JOIN BOOK_SALES BS
    ON B.BOOK_ID=BS.BOOK_ID
  JOIN AUTHOR A
    ON B.AUTHOR_ID=A.AUTHOR_ID
 WHERE DATE_FORMAT(BS.SALES_DATE,"%Y-%m")="2022-01"
 GROUP BY A.AUTHOR_NAME, B.CATEGORY
 ORDER BY B.AUTHOR_ID, B.CATEGORY DESC